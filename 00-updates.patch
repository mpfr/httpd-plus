
Copyright (c) 2020, 2021 Matthias Pressfreund

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Index: usr.sbin/httpd/config.c
@@ -489,7 +489,12 @@
 		/* Inherit configuration from the parent */
 		f = SRVFLAG_INDEX|SRVFLAG_NO_INDEX;
 		if ((srv_conf->flags & f) == 0) {
-			srv_conf->flags |= parent->flags & f;
+			/*
+			 * Inherit index flags from parent server only if
+			 * auto-index flag of location is not set
+			 */
+			if ((srv_conf->flags & SRVFLAG_AUTO_INDEX) == 0)
+				srv_conf->flags |= parent->flags & f;
 			(void)strlcpy(srv_conf->index, parent->index,
 			    sizeof(srv_conf->index));
 		}
Index: usr.sbin/httpd/control.c
@@ -34,7 +34,7 @@
 
 #define	CONTROL_BACKLOG	5
 
-struct ctl_connlist ctl_conns;
+struct ctl_connlist ctl_conns = TAILQ_HEAD_INITIALIZER(ctl_conns);
 
 void		 control_accept(int, short, void *);
 void		 control_close(int, struct control_sock *);
Index: usr.sbin/httpd/httpd.8
@@ -1,5 +1,6 @@
 .\"	$OpenBSD: httpd.8,v 1.53 2016/09/15 20:57:07 jmc Exp $
 .\"
+.\" Copyright (c) 2021 Matthias Pressfreund
 .\" Copyright (c) 2014 Reyk Floeter <reyk@openbsd.org>
 .\"
 .\" Permission to use, copy, modify, and distribute this software for any
@@ -41,6 +42,10 @@
 .Dv SIGHUP
 and reopens log files when it receives
 .Dv SIGUSR1 .
+.Pp
+It is furthermore equipped with the additional functionality provided by the
+.Lk https://github.com/mpfr/httpd-plus httpd-plus
+add-on package.
 .Pp
 The options are as follows:
 .Bl -tag -width Dssmacro=value
Index: usr.sbin/httpd/httpd.conf.5
@@ -1,5 +1,6 @@
 .\"	$OpenBSD: httpd.conf.5,v 1.115 2021/04/06 06:28:38 jmc Exp $
 .\"
+.\" Copyright (c) 2020, 2021 Matthias Pressfreund
 .\" Copyright (c) 2014, 2015 Reyk Floeter <reyk@openbsd.org>
 .\"
 .\" Permission to use, copy, modify, and distribute this software for any
@@ -14,7 +15,7 @@
 .\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 .\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 .\"
-.Dd $Mdocdate: April 6 2021 $
+.Dd $Mdocdate: June 7 2021 $
 .Dt HTTPD.CONF 5
 .Os
 .Sh NAME
@@ -23,7 +24,10 @@
 .Sh DESCRIPTION
 .Nm
 is the configuration file for the HTTP daemon,
-.Xr httpd 8 .
+.Xr httpd 8 ,
+which is equipped with the additional functionality provided by the
+.Lk https://github.com/mpfr/httpd-plus httpd-plus
+add-on package.
 .Pp
 .Nm
 is divided into the following main sections:
@@ -194,9 +198,8 @@
 response.
 The optional
 .Ar uri
-argument can be used with return codes in the 3xx range to send a
-.Sq Location:
-header for redirection to a specified URI.
+argument can be used with return codes in the 3xx range to send an
+HTTP Location header for redirection to a specified URI.
 .Pp
 It is possible to rewrite the request to redirect it to a different
 external location.
@@ -798,6 +801,7 @@
 	listen on 10.0.0.1 tls port 443
 }
 .Ed
+.Pp
 The request can also be rewritten with the
 .Ic request rewrite
 directive:
@@ -808,6 +812,41 @@
 		request rewrite "/new/%1"
 	}
 }
+.Ed
+The
+.Ic location not found
+option may be used to enable
+.Lk https://wordpress.org/support/article/using-permalinks/ WordPress Pretty Permalinks
+just like on an Apache web server with
+.Pa mod_rewrite
+installed.
+.Bd -literal -offset indent
+server "www.example.com" {
+	listen on * port www
+	directory index "index.php"
+
+	location not found "/*" {
+		request rewrite "/index.php"
+	}
+	location "/*.php" {
+		fastcgi socket "/run/php-fpm.sock"
+	}
+}
+.Ed
+WordPress, however, is unable to discover that
+.Xr httpd 8
+is now capable to perform required URL rewrites.
+This will make the
+.Lk https://wordpress.org/support/article/settings-permalinks-screen/ Permalink Settings Screen
+not behave as expected.
+Luckily, and for this case exactly, the
+.Lk https://developer.wordpress.org/reference/hooks/got_url_rewrite/ got_url_rewrite hook
+exists.
+Adding the following line of code into the current theme's
+.Pa functions.php
+file will straighten things out.
+.Bd -literal -offset indent
+add_filter('got_url_rewrite', '__return_true');
 .Ed
 .Sh SEE ALSO
 .Xr htpasswd 1 ,
Index: usr.sbin/httpd/httpd.h
@@ -300,6 +300,7 @@
 	int			 end;
 	int			 status;
 	int			 headersdone;
+	int			 headerssent;
 };
 
 struct range {
@@ -613,8 +614,6 @@
 struct ctl_conn	*
 	 control_connbyfd(int);
 
-extern  struct ctl_connlist ctl_conns;
-
 /* parse.y */
 int	 parse_config(const char *, struct httpd *);
 int	 load_config(const char *, struct httpd *);
@@ -666,6 +665,9 @@
 
 SPLAY_PROTOTYPE(client_tree, client, clt_nodes, server_client_cmp);
 
+#define open_server_root(srv_conf, mode)				\
+	open(*(srv_conf)->root != '\0' ? (srv_conf)->root : "/", mode)
+
 /* server_http.c */
 void	 server_http_init(struct server *);
 void	 server_http(void);
@@ -694,7 +696,6 @@
 	 server_root_strip(const char *, int);
 struct server_config *
 	 server_getlocation(struct client *, const char *);
-int	 server_locationaccesstest(struct server_config *, const char *);
 const char *
 	 server_http_host(struct sockaddr_storage *, char *, size_t);
 char	*server_http_parsehost(char *, char *, size_t, int *);
Index: usr.sbin/httpd/proc.c
@@ -588,7 +588,6 @@
 	proc_setup(ps, procs, nproc);
 	proc_accept(ps, PROC_PARENT_SOCK_FILENO, PROC_PARENT, 0);
 	if (p->p_id == PROC_CONTROL && ps->ps_instance == 0) {
-		TAILQ_INIT(&ctl_conns);
 		if (control_listen(&ps->ps_csock) == -1)
 			fatalx("%s: control_listen", __func__);
 		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
Index: usr.sbin/httpd/server_fcgi.c
@@ -114,6 +114,7 @@
 	clt->clt_fcgi.toread = sizeof(struct fcgi_record_header);
 	clt->clt_fcgi.status = 200;
 	clt->clt_fcgi.headersdone = 0;
+	clt->clt_fcgi.headerssent = 0;
 
 	if (clt->clt_srvevb != NULL)
 		evbuffer_free(clt->clt_srvevb);
@@ -544,22 +545,20 @@
 				if (!clt->clt_fcgi.headersdone) {
 					clt->clt_fcgi.headersdone =
 					    server_fcgi_getheaders(clt);
-					if (clt->clt_fcgi.headersdone) {
-						if (server_fcgi_header(clt,
-						    clt->clt_fcgi.status)
-						    == -1) {
-							server_abort_http(clt,
-							    500,
-							    "malformed fcgi "
-							    "headers");
-							return;
-						}
-					}
 					if (!EVBUFFER_LENGTH(clt->clt_srvevb))
 						break;
 				}
 				/* FALLTHROUGH */
 			case FCGI_END_REQUEST:
+				if (clt->clt_fcgi.headersdone &&
+				    !clt->clt_fcgi.headerssent) {
+					if (server_fcgi_header(clt,
+					    clt->clt_fcgi.status) == -1) {
+						server_abort_http(clt, 500,
+						    "malformed fcgi headers");
+						return;
+					}
+				}
 				if (server_fcgi_writechunk(clt) == -1) {
 					server_abort_http(clt, 500,
 					    "encoding error");
@@ -600,6 +599,8 @@
 	char			 tmbuf[32];
 	struct kv		*kv, *cl, key;
 
+	clt->clt_fcgi.headerssent = 1;
+
 	if (desc == NULL || (error = server_httperror_byid(code)) == NULL)
 		return (-1);
 
@@ -615,6 +616,20 @@
 	if (kv_add(&resp->http_headers, "Server", HTTPD_SERVERNAME) == NULL)
 		return (-1);
 
+	if (clt->clt_fcgi.type == FCGI_END_REQUEST ||
+	    EVBUFFER_LENGTH(clt->clt_srvevb) == 0) {
+		/* Can't chunk encode an empty body. */
+		clt->clt_fcgi.chunked = 0;
+
+		/* But then we need a Content-Length... */
+		key.kv_key = "Content-Length";
+		if ((kv = kv_find(&resp->http_headers, &key)) == NULL) {
+			if (kv_add(&resp->http_headers,
+			    "Content-Length", "0") == NULL)
+				return (-1);
+		}
+	}
+
 	/* Set chunked encoding */
 	if (clt->clt_fcgi.chunked) {
 		/* XXX Should we keep and handle Content-Length instead? */
@@ -660,7 +675,6 @@
 	    kv_add(&resp->http_headers, "Date", tmbuf) == NULL))
 		return (-1);
 
-	/* Write initial header (fcgi might append more) */
 	if (server_writeresponse_http(clt) == -1 ||
 	    server_bufferevent_print(clt, "\r\n") == -1 ||
 	    server_headers(clt, resp, server_writeheader_http, NULL) == -1 ||
Index: usr.sbin/httpd/server_file.c
@@ -85,9 +85,7 @@
 		if (path[strlen(path) - 1] != '/') {
 			if ((encodedpath = url_encode(desc->http_path)) == NULL)
 				return (500);
-			if (asprintf(&newpath, "http%s://%s%s/",
-			    srv_conf->flags & SRVFLAG_TLS ? "s" : "",
-			    desc->http_host, encodedpath) == -1) {
+			if (asprintf(&newpath, "%s/", encodedpath) == -1) {
 				free(encodedpath);
 				return (500);
 			}
@@ -167,10 +165,17 @@
 	struct server_config	*srv_conf = clt->clt_srv_conf;
 	char			 path[PATH_MAX];
 	const char		*stripped, *errstr = NULL;
-	int			 ret = 500;
+	int			 ret = 500, rootfd;
 
 	if (srv_conf->flags & SRVFLAG_FCGI)
 		return (server_fcgi(env, clt));
+
+	/* If the server root is not accessible, we have a problem */
+	if ((rootfd = open_server_root(srv_conf, O_RDONLY)) == -1) {
+		errstr = srv_conf->root;
+		goto abort;
+	}
+	close(rootfd);
 
 	/* Request path is already canonicalized */
 	stripped = server_root_strip(
Index: usr.sbin/httpd/server_http.c
@@ -51,6 +51,8 @@
 		    struct client *);
 char		*server_expand_http(struct client *, const char *,
 		    char *, size_t);
+int		 server_locationaccesstest(struct server_config *,
+		    const char *);
 
 static struct http_method	 http_methods[] = HTTP_METHODS;
 static struct http_error	 http_errors[] = HTTP_ERRORS;
@@ -1320,10 +1322,8 @@
 		goto fail;
 
 	/* Now search for the location */
-	if ((srv_conf = server_getlocation(clt, desc->http_path)) == NULL) {
-		server_abort_http(clt, 500, desc->http_path);
-		return (-1);
-	}
+	if ((srv_conf = server_getlocation(clt, desc->http_path)) == NULL)
+		goto rooterr;
 
 	/* Optional rewrite */
 	if (srv_conf->flags & SRVFLAG_PATH_REWRITE) {
@@ -1360,10 +1360,8 @@
 
 		/* Now search for the updated location */
 		if ((srv_conf = server_getlocation(clt,
-		    desc->http_path_alias)) == NULL) {
-			server_abort_http(clt, 500, desc->http_path_alias);
-			return (-1);
-		}
+		    desc->http_path_alias)) == NULL)
+			goto rooterr;
 	}
 
 	if (clt->clt_toread > 0 && (size_t)clt->clt_toread >
@@ -1385,6 +1383,11 @@
  fail:
 	server_abort_http(clt, 400, "bad request");
 	return (-1);
+
+ rooterr: /* server root inaccessible */
+	srv_conf = clt->clt_srv_conf;
+	server_abort_http(clt, 500, srv_conf->root);
+	return (-1);
 }
 
 const char *
@@ -1455,7 +1458,8 @@
 	    srv_conf->flags) == 0)
 		return (0);
 
-	if ((rootfd = open(srv_conf->root, O_RDONLY)) == -1)
+	/* If the server root is not accessible, we have a problem */
+	if ((rootfd = open_server_root(srv_conf, O_RDONLY)) == -1)
 		return (-1);
 
 	path = server_root_strip(path, srv_conf->strip) + 1;
