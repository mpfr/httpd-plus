
Copyright (c) 2020, 2021 Matthias Pressfreund

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Index: usr.sbin/httpd/config.c
@@ -18,6 +18,8 @@
 
 #include <sys/types.h>
 #include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 #include <sys/tree.h>
 #include <sys/time.h>
 #include <sys/uio.h>
@@ -135,9 +137,7 @@
 int
 config_getcfg(struct httpd *env, struct imsg *imsg)
 {
-	struct privsep		*ps = env->sc_ps;
 	struct ctl_flags	 cf;
-	unsigned int		 what;
 
 	if (IMSG_DATA_SIZE(imsg) != sizeof(cf))
 		return (0); /* ignore */
@@ -148,8 +148,6 @@
 	env->sc_flags = cf.cf_flags;
 	memcpy(env->sc_tls_sid, cf.cf_tls_sid, sizeof(env->sc_tls_sid));
 
-	what = ps->ps_what[privsep_process];
-
 	if (privsep_process != PROC_PARENT)
 		proc_compose(env->sc_ps, PROC_PARENT,
 		    IMSG_CFG_DONE, NULL, 0);
@@ -387,8 +385,10 @@
 	if (proc_composev(ps, PROC_SERVER, IMSG_CFG_FCGI, iov, c) != 0) {
 		log_warn("%s: failed to compose IMSG_CFG_FCGI imsg for "
 		    "`%s'", __func__, srv_conf->name);
+		free(iov);
 		return (-1);
 	}
+	free(iov);
 
 	return (0);
 }
@@ -489,7 +489,12 @@
 		/* Inherit configuration from the parent */
 		f = SRVFLAG_INDEX|SRVFLAG_NO_INDEX;
 		if ((srv_conf->flags & f) == 0) {
-			srv_conf->flags |= parent->flags & f;
+			/*
+			 * Inherit index flags from parent server only if
+			 * auto-index flag of location is not set
+			 */
+			if ((srv_conf->flags & SRVFLAG_AUTO_INDEX) == 0)
+				srv_conf->flags |= parent->flags & f;
 			(void)strlcpy(srv_conf->index, parent->index,
 			    sizeof(srv_conf->index));
 		}
@@ -498,13 +503,6 @@
 		if ((srv_conf->flags & f) == 0)
 			srv_conf->flags |= parent->flags & f;
 
-		f = SRVFLAG_SOCKET|SRVFLAG_FCGI;
-		if ((srv_conf->flags & f) == SRVFLAG_FCGI) {
-			srv_conf->flags |= f;
-			(void)strlcpy(srv_conf->socket, HTTPD_FCGI_SOCKET,
-			    sizeof(srv_conf->socket));
-		}
-
 		f = SRVFLAG_ROOT;
 		if ((srv_conf->flags & f) == 0) {
 			srv_conf->flags |= parent->flags & f;
@@ -683,7 +681,6 @@
 		if ((srv->srv_conf.return_uri = get_data(p + s,
 		    srv->srv_conf.return_uri_len)) == NULL)
 			goto fail;
-		s += srv->srv_conf.return_uri_len;
 	}
 
 	return (0);
Index: usr.sbin/httpd/http.h
@@ -246,6 +246,7 @@
 	/* Rewritten path and query remain NULL if not used */
 	char			*http_path_alias;
 	char			*http_query_alias;
+	char			*http_path_orig;
 
 	/* A tree of headers and attached lists for repeated headers. */
 	struct kv		*http_lastheader;
Index: usr.sbin/httpd/httpd.8
@@ -1,5 +1,6 @@
 .\"	$OpenBSD: httpd.8,v 1.53 2016/09/15 20:57:07 jmc Exp $
 .\"
+.\" Copyright (c) 2021 Matthias Pressfreund
 .\" Copyright (c) 2014 Reyk Floeter <reyk@openbsd.org>
 .\"
 .\" Permission to use, copy, modify, and distribute this software for any
@@ -41,6 +42,10 @@
 .Dv SIGHUP
 and reopens log files when it receives
 .Dv SIGUSR1 .
+.Pp
+It is furthermore equipped with the additional functionality provided by the
+.Lk https://github.com/mpfr/httpd-plus httpd-plus
+add-on package.
 .Pp
 The options are as follows:
 .Bl -tag -width Dssmacro=value
Index: usr.sbin/httpd/httpd.c
@@ -67,6 +67,8 @@
 	{ "logger",	PROC_LOGGER, parent_dispatch_logger, logger }
 };
 
+enum privsep_procid privsep_process;
+
 void
 parent_sig_handler(int sig, short event, void *arg)
 {
@@ -552,59 +554,6 @@
 }
 
 const char *
-canonicalize_host(const char *host, char *name, size_t len)
-{
-	struct sockaddr_in	 sin4;
-	struct sockaddr_in6	 sin6;
-	size_t			 i, j;
-	size_t			 plen;
-	char			 c;
-
-	if (len < 2)
-		goto fail;
-
-	/*
-	 * Canonicalize an IPv4/6 address
-	 */
-	if (inet_pton(AF_INET, host, &sin4) == 1)
-		return (inet_ntop(AF_INET, &sin4, name, len));
-	if (inet_pton(AF_INET6, host, &sin6) == 1)
-		return (inet_ntop(AF_INET6, &sin6, name, len));
-
-	/*
-	 * Canonicalize a hostname
-	 */
-
-	/* 1. remove repeated dots and convert upper case to lower case */
-	plen = strlen(host);
-	memset(name, 0, len);
-	for (i = j = 0; i < plen; i++) {
-		if (j >= (len - 1))
-			goto fail;
-		c = tolower((unsigned char)host[i]);
-		if ((c == '.') && (j == 0 || name[j - 1] == '.'))
-			continue;
-		name[j++] = c;
-	}
-
-	/* 2. remove trailing dots */
-	for (i = j; i > 0; i--) {
-		if (name[i - 1] != '.')
-			break;
-		name[i - 1] = '\0';
-		j--;
-	}
-	if (j <= 0)
-		goto fail;
-
-	return (name);
-
- fail:
-	errno = EINVAL;
-	return (NULL);
-}
-
-const char *
 url_decode(char *url)
 {
 	char		*p, *q;
@@ -1112,50 +1061,6 @@
 }
 
 struct kv *
-kv_inherit(struct kv *dst, struct kv *src)
-{
-	memset(dst, 0, sizeof(*dst));
-	memcpy(dst, src, sizeof(*dst));
-	TAILQ_INIT(&dst->kv_children);
-
-	if (src->kv_key != NULL) {
-		if ((dst->kv_key = strdup(src->kv_key)) == NULL) {
-			kv_free(dst);
-			return (NULL);
-		}
-	}
-	if (src->kv_value != NULL) {
-		if ((dst->kv_value = strdup(src->kv_value)) == NULL) {
-			kv_free(dst);
-			return (NULL);
-		}
-	}
-
-	return (dst);
-}
-
-int
-kv_log(struct evbuffer *log, struct kv *kv)
-{
-	char	*msg;
-
-	if (log == NULL)
-		return (0);
-	if (asprintf(&msg, " [%s%s%s]",
-	    kv->kv_key == NULL ? "(unknown)" : kv->kv_key,
-	    kv->kv_value == NULL ? "" : ": ",
-	    kv->kv_value == NULL ? "" : kv->kv_value) == -1)
-		return (-1);
-	if (evbuffer_add(log, msg, strlen(msg)) == -1) {
-		free(msg);
-		return (-1);
-	}
-	free(msg);
-
-	return (0);
-}
-
-struct kv *
 kv_find(struct kvtree *keys, struct kv *kv)
 {
 	struct kv	*match;
@@ -1323,22 +1228,6 @@
 		buf[0] = '\0';
 		return (NULL);
 	}
-	return (buf);
-}
-
-const char *
-print_time(struct timeval *a, struct timeval *b, char *buf, size_t len)
-{
-	struct timeval		tv;
-	unsigned long		h, sec, min;
-
-	timerclear(&tv);
-	timersub(a, b, &tv);
-	sec = tv.tv_sec % 60;
-	min = tv.tv_sec / 60 % 60;
-	h = tv.tv_sec / 60 / 60;
-
-	snprintf(buf, len, "%.2lu:%.2lu:%.2lu", h, min, sec);
 	return (buf);
 }
 
Index: usr.sbin/httpd/httpd.conf.5
@@ -1,5 +1,6 @@
 .\"	$OpenBSD: httpd.conf.5,v 1.110 2020/04/23 21:10:53 jmc Exp $
 .\"
+.\" Copyright (c) 2020, 2021 Matthias Pressfreund
 .\" Copyright (c) 2014, 2015 Reyk Floeter <reyk@openbsd.org>
 .\"
 .\" Permission to use, copy, modify, and distribute this software for any
@@ -14,7 +15,7 @@
 .\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 .\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 .\"
-.Dd $Mdocdate: April 23 2020 $
+.Dd $Mdocdate: April 6 2021 $
 .Dt HTTPD.CONF 5
 .Os
 .Sh NAME
@@ -23,7 +24,10 @@
 .Sh DESCRIPTION
 .Nm
 is the configuration file for the HTTP daemon,
-.Xr httpd 8 .
+.Xr httpd 8 ,
+which is equipped with the additional functionality provided by the
+.Lk https://github.com/mpfr/httpd-plus httpd-plus
+add-on package.
 .Pp
 .Nm
 is divided into the following main sections:
@@ -155,7 +159,7 @@
 .Xr patterns 7 .
 .El
 .Pp
-Followed by a block of options that is enclosed in curly brackets:
+Followed by a block of options enclosed in curly braces:
 .Bl -tag -width Ds
 .It Ic alias Ar name
 Specify an additional alias
@@ -282,14 +286,16 @@
 .El
 .It Oo Ic no Oc Ic fastcgi Oo Ar option Oc
 Enable FastCGI instead of serving files.
+Multiple options may be specified within curly braces.
 Valid options are:
 .Bl -tag -width Ds
-.It Ic socket Ar socket
+.It Ic socket Oo Cm tcp Oc Ar socket Oo Ar port Oc
 .Nm httpd
 passes HTTP requests to a FastCGI handler listening on the socket
 .Ar socket .
-The socket can either be a UNIX domain socket or a TCP socket listening
-on localhost (127.0.0.1).
+The
+.Ar socket
+can either be a UNIX domain socket or a TCP socket.
 If the FastCGI handler is listening on a UNIX domain socket,
 .Ar socket
 is a local path name within the
@@ -301,7 +307,10 @@
 Alternatively if
 the FastCGI handler is listening on a TCP socket,
 .Ar socket
-starts with a colon followed by the TCP port number.
+is a hostname or an IP address.
+If the
+.Ar port
+is not specified, it defaults to port 9000.
 .It Ic strip Ar number
 Strip
 .Ar number
@@ -395,11 +404,16 @@
 .It Ic listen on Ar address Oo Ic tls Oc Ic port Ar number
 Set the listen address and port.
 This statement can be specified multiple times.
-.It Ic location Ar path Brq ...
+.It Ic location Oo Oo Ic not Oc Ic found Oc Ar path Brq ...
 Specify server configuration rules for a specific location.
 The
 .Ar path
 argument will be matched against the request path with shell globbing rules.
+Optionally, it is also possible to match for
+.Ic found
+(i.e. accessible) or
+.Ic not found
+request paths only.
 In case of multiple location statements in the same context, the
 first matching location statement will be put into effect, while all
 later ones will be ignored.
@@ -415,7 +429,7 @@
 .Ic tcp
 and
 .Ic tls .
-.It Ic location match Ar path Brq ...
+.It Ic location Oo Oo Ic not Oc Ic found Oc Ic match Ar path Brq ...
 Like the
 .Ic location
 option,
@@ -699,6 +713,11 @@
 Include types definitions from an external file, for example
 .Pa /usr/share/misc/mime.types .
 .El
+.Sh FILES
+.Bl -tag -width /etc/examples/httpd.conf -compact
+.It Pa /etc/examples/httpd.conf
+Example configuration file.
+.El
 .Sh EXAMPLES
 Example configuration files for
 .Nm
@@ -795,6 +814,41 @@
 		request rewrite "/new/%1"
 	}
 }
+.Ed
+The
+.Ic location not found
+option may be used to enable
+.Lk https://wordpress.org/support/article/using-permalinks/ WordPress Pretty Permalinks
+just like on an Apache web server with
+.Pa mod_rewrite
+installed.
+.Bd -literal -offset indent
+server "www.example.com" {
+	listen on * port www
+	directory index "index.php"
+
+	location not found "/*" {
+		request rewrite "/index.php"
+	}
+	location "/*.php" {
+		fastcgi socket "/run/php-fpm.sock"
+	}
+}
+.Ed
+WordPress, however, is unable to discover that
+.Xr httpd 8
+is now capable to perform required URL rewrites.
+This will make the
+.Lk https://wordpress.org/support/article/settings-permalinks-screen/ Permalink Settings Screen
+not behave as expected.
+Luckily, and for this case exactly, the
+.Lk https://developer.wordpress.org/reference/hooks/got_url_rewrite/ got_url_rewrite hook
+exists.
+Adding the following line of code into the current theme's
+.Pa functions.php
+file will straighten things out.
+.Bd -literal -offset indent
+add_filter('got_url_rewrite', '__return_true');
 .Ed
 .Sh SEE ALSO
 .Xr htpasswd 1 ,
Index: usr.sbin/httpd/httpd.h
@@ -1,6 +1,7 @@
 /*	$OpenBSD: httpd.h,v 1.146 2020/02/09 09:44:04 florian Exp $	*/
 
 /*
+ * Copyright (c) 2020 Matthias Pressfreund
  * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>
  * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@openbsd.org>
  * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
@@ -96,6 +97,7 @@
 #define CONFIG_ALL		0xff
 
 #define FCGI_CONTENT_SIZE	65535
+#define FCGI_DEFAULT_PORT	"9000"
 
 #define PROC_PARENT_SOCK_FILENO	3
 #define PROC_MAX_INSTANCES	32
@@ -121,16 +123,6 @@
 	uint8_t		 cf_tls_sid[TLS_MAX_SESSION_ID_LENGTH];
 };
 
-enum key_type {
-	KEY_TYPE_NONE		= 0,
-	KEY_TYPE_COOKIE,
-	KEY_TYPE_HEADER,
-	KEY_TYPE_PATH,
-	KEY_TYPE_QUERY,
-	KEY_TYPE_URL,
-	KEY_TYPE_MAX
-};
-
 TAILQ_HEAD(kvlist, kv);
 RB_HEAD(kvtree, kv);
 
@@ -138,8 +130,6 @@
 	char			*kv_key;
 	char			*kv_value;
 
-	enum key_type		 kv_type;
-
 #define KV_FLAG_INVALID		 0x01
 #define KV_FLAG_GLOBBING	 0x02
 	uint8_t			 kv_flags;
@@ -179,7 +169,7 @@
 };
 TAILQ_HEAD(control_socks, control_sock);
 
-struct {
+extern struct {
 	struct event	 ev;
 	int		 fd;
 } control_state;
@@ -241,7 +231,8 @@
 	PROC_SERVER,
 	PROC_LOGGER,
 	PROC_MAX
-} privsep_process;
+};
+extern enum privsep_procid privsep_process;
 
 /* Attach the control socket to the following process */
 #define PROC_CONTROL	PROC_LOGGER
@@ -387,7 +378,6 @@
 #define SRVFLAG_NO_FCGI		0x00000080
 #define SRVFLAG_LOG		0x00000100
 #define SRVFLAG_NO_LOG		0x00000200
-#define SRVFLAG_SOCKET		0x00000400
 #define SRVFLAG_SYSLOG		0x00000800
 #define SRVFLAG_NO_SYSLOG	0x00001000
 #define SRVFLAG_TLS		0x00002000
@@ -403,13 +393,16 @@
 #define SRVFLAG_DEFAULT_TYPE	0x00800000
 #define SRVFLAG_PATH_REWRITE	0x01000000
 #define SRVFLAG_NO_PATH_REWRITE	0x02000000
+#define SRVFLAG_LOCATION_FOUND	0x40000000
+#define SRVFLAG_LOCATION_NOT_FOUND 0x80000000
 
 #define SRVFLAG_BITS							\
 	"\10\01INDEX\02NO_INDEX\03AUTO_INDEX\04NO_AUTO_INDEX"		\
-	"\05ROOT\06LOCATION\07FCGI\10NO_FCGI\11LOG\12NO_LOG\13SOCKET"	\
+	"\05ROOT\06LOCATION\07FCGI\10NO_FCGI\11LOG\12NO_LOG"		\
 	"\14SYSLOG\15NO_SYSLOG\16TLS\17ACCESS_LOG\20ERROR_LOG"		\
 	"\21AUTH\22NO_AUTH\23BLOCK\24NO_BLOCK\25LOCATION_MATCH"		\
-	"\26SERVER_MATCH\27SERVER_HSTS\30DEFAULT_TYPE\31PATH\32NO_PATH"
+	"\26SERVER_MATCH\27SERVER_HSTS\30DEFAULT_TYPE\31PATH\32NO_PATH" \
+	"\37LOCATION_FOUND\40LOCATION_NOT_FOUND"
 
 #define TCPFLAG_NODELAY		0x01
 #define TCPFLAG_NNODELAY	0x02
@@ -447,7 +440,7 @@
 	uint32_t		log_id;
 	TAILQ_ENTRY(log_file)	log_entry;
 };
-TAILQ_HEAD(log_files, log_file) log_files;
+extern TAILQ_HEAD(log_files, log_file) log_files;
 
 struct media_type {
 	char			 media_name[MEDIATYPE_NAMEMAX];
@@ -487,11 +480,12 @@
 	char			 root[PATH_MAX];
 	char			 path[PATH_MAX];
 	char			 index[PATH_MAX];
-	char			 socket[PATH_MAX];
 	char			 accesslog[PATH_MAX];
 	char			 errorlog[PATH_MAX];
 	struct media_type	 default_type;
 
+	struct sockaddr_storage	 fastcgi_ss;
+
 	in_port_t		 port;
 	struct sockaddr_storage	 ss;
 	int			 prefixlen;
@@ -629,7 +623,7 @@
 
 /* server.c */
 void	 server(struct privsep *, struct privsep_proc *);
-int	 server_tls_cmp(struct server *, struct server *, int);
+int	 server_tls_cmp(struct server *, struct server *);
 int	 server_tls_load_ca(struct server *);
 int	 server_tls_load_crl(struct server *);
 int	 server_tls_load_keypair(struct server *);
@@ -673,6 +667,9 @@
 
 SPLAY_PROTOTYPE(client_tree, client, clt_nodes, server_client_cmp);
 
+#define open_server_root(srv_conf, mode)				\
+	open(*(srv_conf)->root != '\0' ? (srv_conf)->root : "/", mode)
+
 /* server_http.c */
 void	 server_http_init(struct server *);
 void	 server_http(void);
@@ -722,7 +719,6 @@
 int		 expand_string(char *, size_t, const char *, const char *);
 const char	*url_decode(char *);
 char		*url_encode(const char *);
-const char	*canonicalize_host(const char *, char *, size_t);
 const char	*canonicalize_path(const char *, char *, size_t);
 size_t		 path_info(char *);
 char		*escape_html(const char *);
@@ -744,8 +740,6 @@
 struct kv	*kv_extend(struct kvtree *, struct kv *, char *);
 void		 kv_purge(struct kvtree *);
 void		 kv_free(struct kv *);
-struct kv	*kv_inherit(struct kv *, struct kv *);
-int		 kv_log(struct evbuffer *, struct kv *);
 struct kv	*kv_find(struct kvtree *, struct kv *);
 int		 kv_cmp(struct kv *, struct kv *);
 struct media_type
@@ -764,7 +758,6 @@
 struct auth	*auth_byid(struct serverauth *, uint32_t);
 void		 auth_free(struct serverauth *, struct auth *);
 const char	*print_host(struct sockaddr_storage *, char *, size_t);
-const char	*print_time(struct timeval *, struct timeval *, char *, size_t);
 const char	*printb_flags(const uint32_t, const char *);
 void		 getmonotime(struct timeval *);
 
Index: usr.sbin/httpd/logger.c
@@ -45,6 +45,8 @@
 
 static uint32_t		 last_log_id = 0;
 
+struct log_files log_files;
+
 static struct privsep_proc procs[] = {
 	{ "parent",	PROC_PARENT,	logger_dispatch_parent },
 	{ "server",	PROC_SERVER,	logger_dispatch_server }
@@ -89,6 +91,7 @@
 			log->log_fd = -1;
 		}
 		TAILQ_REMOVE(&log_files, log, log_entry);
+		free(log);
 	}
 }
 
Index: usr.sbin/httpd/parse.y
@@ -1,6 +1,7 @@
 /*	$OpenBSD: parse.y,v 1.114 2020/02/09 09:44:04 florian Exp $	*/
 
 /*
+ * Copyright (c) 2020 Matthias Pressfreund
  * Copyright (c) 2007 - 2015 Reyk Floeter <reyk@openbsd.org>
  * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org>
  * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@openbsd.org>
@@ -27,6 +28,7 @@
 %{
 #include <sys/types.h>
 #include <sys/socket.h>
+#include <sys/un.h>
 #include <sys/stat.h>
 #include <sys/queue.h>
 #include <sys/tree.h>
@@ -116,6 +118,8 @@
 int		 listen_on(const char *, int, struct portrange *);
 int		 getservice(char *);
 int		 is_if_in_group(const char *, const char *);
+int		 get_fastcgi_dest(struct server_config *, const char *, char *);
+void		 remove_locations(struct server_config *);
 
 typedef struct {
 	union {
@@ -124,10 +128,6 @@
 		struct timeval		 tv;
 		struct portrange	 port;
 		struct auth		 auth;
-		struct {
-			struct sockaddr_storage	 ss;
-			char			 name[HOST_NAME_MAX+1];
-		}			 addr;
 	} v;
 	int lineno;
 } YYSTYPE;
@@ -140,11 +140,12 @@
 %token	PROTOCOLS REQUESTS ROOT SACK SERVER SOCKET STRIP STYLE SYSLOG TCP TICKET
 %token	TIMEOUT TLS TYPE TYPES HSTS MAXAGE SUBDOMAINS DEFAULT PRELOAD REQUEST
 %token	ERROR INCLUDE AUTHENTICATE WITH BLOCK DROP RETURN PASS REWRITE
-%token	CA CLIENT CRL OPTIONAL PARAM FORWARDED
+%token	CA CLIENT CRL OPTIONAL PARAM FORWARDED FOUND NOT
 %token	<v.string>	STRING
 %token  <v.number>	NUMBER
 %type	<v.port>	port
-%type	<v.number>	opttls optmatch
+%type	<v.string>	fcgiport
+%type	<v.number>	opttls optmatch optfound
 %type	<v.tv>		timeout
 %type	<v.string>	numberstring optstring
 %type	<v.auth>	authopts
@@ -221,7 +222,8 @@
 		;
 
 server		: SERVER optmatch STRING	{
-			struct server	*s;
+			struct server		*s;
+			struct sockaddr_un	*sun;
 
 			if (!loadcfg) {
 				free($3);
@@ -278,6 +280,12 @@
 			    HTTPD_TLS_ECDHE_CURVES,
 			    sizeof(s->srv_conf.tls_ecdhe_curves));
 
+			sun = (struct sockaddr_un *)&s->srv_conf.fastcgi_ss;
+			sun->sun_family = AF_UNIX;
+			(void)strlcpy(sun->sun_path, HTTPD_FCGI_SOCKET,
+			    sizeof(sun->sun_path));
+			sun->sun_len = sizeof(struct sockaddr_un);
+
 			s->srv_conf.hsts_max_age = SERVER_HSTS_DEFAULT_AGE;
 
 			if (last_server_id == INT_MAX) {
@@ -325,7 +333,8 @@
 					free(srv);
 					YYERROR;
 				}
-				if (server_tls_cmp(s, srv, 0) != 0) {
+				if (srv->srv_conf.flags & SRVFLAG_TLS &&
+				    server_tls_cmp(s, srv) != 0) {
 					yyerror("server \"%s\": tls "
 					    "configuration mismatch on same "
 					    "address/port",
@@ -345,11 +354,20 @@
 				YYERROR;
 			}
 
-			if (server_tls_load_keypair(srv) == -1)
+			if (server_tls_load_keypair(srv) == -1) {
+				/* Soft fail as there may be no certificate. */
 				log_warnx("%s:%d: server \"%s\": failed to "
 				    "load public/private keys", file->name,
 				    yylval.lineno, srv->srv_conf.name);
 
+				remove_locations(srv_conf);
+				serverconfig_free(srv_conf);
+				srv_conf = NULL;
+				free(srv);
+				srv = NULL;
+				break;
+			}
+
 			if (server_tls_load_ca(srv) == -1) {
 				yyerror("server \"%s\": failed to load "
 				    "ca cert(s)", srv->srv_conf.name);
@@ -496,38 +514,39 @@
 		| fastcgi
 		| authenticate
 		| filter
-		| LOCATION optmatch STRING	{
-			struct server	*s;
+		| LOCATION optfound optmatch STRING	{
+			struct server		*s;
+			struct sockaddr_un	*sun;
 
 			if (srv->srv_conf.ss.ss_family == AF_UNSPEC) {
 				yyerror("listen address not specified");
-				free($3);
+				free($4);
 				YYERROR;
 			}
 
 			if (parentsrv != NULL) {
-				yyerror("location %s inside location", $3);
-				free($3);
+				yyerror("location %s inside location", $4);
+				free($4);
 				YYERROR;
 			}
 
 			if (!loadcfg) {
-				free($3);
+				free($4);
 				YYACCEPT;
 			}
 
 			if ((s = calloc(1, sizeof (*s))) == NULL)
 				fatal("out of memory");
 
-			if (strlcpy(s->srv_conf.location, $3,
+			if (strlcpy(s->srv_conf.location, $4,
 			    sizeof(s->srv_conf.location)) >=
 			    sizeof(s->srv_conf.location)) {
 				yyerror("server location truncated");
-				free($3);
+				free($4);
 				free(s);
 				YYERROR;
 			}
-			free($3);
+			free($4);
 
 			if (strlcpy(s->srv_conf.name, srv->srv_conf.name,
 			    sizeof(s->srv_conf.name)) >=
@@ -537,11 +556,28 @@
 				YYERROR;
 			}
 
+			sun = (struct sockaddr_un *)&s->srv_conf.fastcgi_ss;
+			sun->sun_family = AF_UNIX;
+			(void)strlcpy(sun->sun_path, HTTPD_FCGI_SOCKET,
+			    sizeof(sun->sun_path));
+			sun->sun_len = sizeof(struct sockaddr_un);
+
 			s->srv_conf.id = ++last_server_id;
 			/* A location entry uses the parent id */
 			s->srv_conf.parent_id = srv->srv_conf.id;
 			s->srv_conf.flags = SRVFLAG_LOCATION;
-			if ($2)
+			if ($2 == 1) {
+				s->srv_conf.flags &=
+				    ~SRVFLAG_LOCATION_NOT_FOUND;
+				s->srv_conf.flags |=
+				    SRVFLAG_LOCATION_FOUND;
+			} else if ($2 == -1) {
+				s->srv_conf.flags &=
+				    ~SRVFLAG_LOCATION_FOUND;
+				s->srv_conf.flags |=
+				    SRVFLAG_LOCATION_NOT_FOUND;
+			}
+			if ($3)
 				s->srv_conf.flags |= SRVFLAG_LOCATION_MATCH;
 			s->srv_s = -1;
 			memcpy(&s->srv_conf.ss, &srv->srv_conf.ss,
@@ -561,10 +597,18 @@
 			SPLAY_INIT(&srv->srv_clients);
 		} '{' optnl serveropts_l '}'	{
 			struct server	*s = NULL;
+			uint32_t	 f;
 
+			f = SRVFLAG_LOCATION_FOUND |
+			    SRVFLAG_LOCATION_NOT_FOUND;
+
 			TAILQ_FOREACH(s, conf->sc_servers, srv_entry) {
+				/* Compare locations of same parent server */
 				if ((s->srv_conf.flags & SRVFLAG_LOCATION) &&
-				    s->srv_conf.id == srv_conf->id &&
+				    s->srv_conf.parent_id ==
+				    srv_conf->parent_id &&
+				    (s->srv_conf.flags & f) ==
+				    (srv_conf->flags & f) &&
 				    strcmp(s->srv_conf.location,
 				    srv_conf->location) == 0)
 					break;
@@ -602,6 +646,11 @@
 		}
 		;
 
+optfound	: /* empty */	{ $$ = 0; }
+		| FOUND		{ $$ = 1; }
+		| NOT FOUND	{ $$ = -1; }
+		;
+
 hsts		: HSTS '{' optnl hstsflags_l '}'
 		| HSTS hstsflags
 		| HSTS
@@ -648,17 +697,38 @@
 		| fcgiflags optnl
 		;
 
-fcgiflags	: SOCKET STRING		{
-			if (strlcpy(srv_conf->socket, $2,
-			    sizeof(srv_conf->socket)) >=
-			    sizeof(srv_conf->socket)) {
-				yyerror("fastcgi socket too long");
+fcgiflags	: SOCKET STRING {
+			struct sockaddr_un *sun;
+			sun = (struct sockaddr_un *)&srv_conf->fastcgi_ss;
+			memset(sun, 0, sizeof(*sun));
+			sun->sun_family = AF_UNIX;
+			if (strlcpy(sun->sun_path, $2, sizeof(sun->sun_path))
+			    >= sizeof(sun->sun_path)) {
+				yyerror("socket path too long");
 				free($2);
 				YYERROR;
 			}
+			srv_conf->fastcgi_ss.ss_len =
+			    sizeof(struct sockaddr_un);
 			free($2);
-			srv_conf->flags |= SRVFLAG_SOCKET;
 		}
+		| SOCKET TCP STRING {
+			if (get_fastcgi_dest(srv_conf, $3, FCGI_DEFAULT_PORT)
+			    == -1) {
+				free($3);
+				YYERROR;
+			}
+			free($3);
+		}
+		| SOCKET TCP STRING fcgiport {
+			if (get_fastcgi_dest(srv_conf, $3, $4) == -1) {
+				free($3);
+				free($4);
+				YYERROR;
+			}
+			free($3);
+			free($4);
+		}
 		| PARAM STRING STRING	{
 			struct fastcgi_param	*param;
 
@@ -1086,6 +1156,27 @@
 		| STRING		{ $$ = $1; }
 		;
 
+fcgiport	: NUMBER		{
+			if ($1 <= 0 || $1 > (int)USHRT_MAX) {
+				yyerror("invalid port: %lld", $1);
+				YYERROR;
+			}
+			if (asprintf(&$$, "%lld", $1) == -1) {
+				yyerror("out of memory");
+				YYERROR;
+			}
+		}
+		| STRING		{
+			if (getservice($1) <= 0) {
+				yyerror("invalid port: %s", $1);
+				free($1);
+				YYERROR;
+			}
+
+			$$ = $1;
+		}
+		;
+
 tcpip		: TCP '{' optnl tcpflags_l '}'
 		| TCP tcpflags
 		;
@@ -1308,6 +1399,7 @@
 		{ "error",		ERR },
 		{ "fastcgi",		FCGI },
 		{ "forwarded",		FORWARDED },
+		{ "found",		FOUND },
 		{ "hsts",		HSTS },
 		{ "include",		INCLUDE },
 		{ "index",		INDEX },
@@ -1323,6 +1415,7 @@
 		{ "max-age",		MAXAGE },
 		{ "no",			NO },
 		{ "nodelay",		NODELAY },
+		{ "not",		NOT },
 		{ "ocsp",		OCSP },
 		{ "on",			ON },
 		{ "optional",		OPTIONAL },
@@ -2035,7 +2128,8 @@
 
  nextaf:
 	for (p = ifap; p != NULL && cnt < max; p = p->ifa_next) {
-		if (p->ifa_addr->sa_family != af ||
+		if (p->ifa_addr == NULL ||
+		    p->ifa_addr->sa_family != af ||
 		    (strcmp(s, p->ifa_name) != 0 &&
 		    !is_if_in_group(p->ifa_name, s)))
 			continue;
@@ -2050,6 +2144,7 @@
 				log_warnx("%s: interface name truncated",
 				    __func__);
 			freeifaddrs(ifap);
+			free(h);
 			return (-1);
 		}
 		if (ipproto != -1)
@@ -2326,10 +2421,8 @@
 		s = getservbyname(n, "tcp");
 		if (s == NULL)
 			s = getservbyname(n, "udp");
-		if (s == NULL) {
-			yyerror("unknown port %s", n);
+		if (s == NULL)
 			return (-1);
-		}
 		return (s->s_port);
 	}
 
@@ -2378,4 +2471,42 @@
 end:
 	close(s);
 	return (ret);
+}
+
+int
+get_fastcgi_dest(struct server_config *xsrv_conf, const char *node, char *port)
+{
+	struct addrinfo		 hints, *res;
+	int			 s;
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+
+	if ((s = getaddrinfo(node, port, &hints, &res)) != 0) {
+		yyerror("getaddrinfo: %s\n", gai_strerror(s));
+		return -1;
+	}
+
+	memset(&(xsrv_conf)->fastcgi_ss, 0, sizeof(xsrv_conf->fastcgi_ss));
+	memcpy(&(xsrv_conf)->fastcgi_ss, res->ai_addr, res->ai_addrlen);
+
+	freeaddrinfo(res);
+
+	return (0);
+}
+
+void
+remove_locations(struct server_config *xsrv_conf)
+{
+	struct server *s, *next;
+
+	TAILQ_FOREACH_SAFE(s, conf->sc_servers, srv_entry, next) {
+		if (!(s->srv_conf.flags & SRVFLAG_LOCATION &&
+		    s->srv_conf.parent_id == xsrv_conf->parent_id))
+			continue;
+		TAILQ_REMOVE(conf->sc_servers, s, srv_entry);
+		serverconfig_free(&s->srv_conf);
+		free(s);
+	}
 }
Index: usr.sbin/httpd/proc.c
@@ -401,7 +401,7 @@
 			free(cause);
 		} else
 			log_warnx("lost child: pid %u", pid);
-	} while (pid != -1 || (pid == -1 && errno == EINTR));
+	} while (pid != -1 || errno == EINTR);
 }
 
 void
Index: usr.sbin/httpd/server.c
@@ -119,13 +119,6 @@
 	}
 
 	/* Open listening socket in the privileged process */
-	if ((srv->srv_conf.flags & SRVFLAG_TLS) && srv->srv_conf.tls_cert ==
-	    NULL) {
-		/* soft fail if cert is not there yet */
-		srv->srv_s = -1;
-		return (0);
-	}
-
 	if ((srv->srv_s = server_socket_listen(&srv->srv_conf.ss,
 	    srv->srv_conf.port, &srv->srv_conf)) == -1)
 		return (-1);
@@ -134,7 +127,7 @@
 }
 
 int
-server_tls_cmp(struct server *s1, struct server *s2, int match_keypair)
+server_tls_cmp(struct server *s1, struct server *s2)
 {
 	struct server_config	*sc1, *sc2;
 
@@ -154,13 +147,6 @@
 	if (strcmp(sc1->tls_ecdhe_curves, sc2->tls_ecdhe_curves) != 0)
 		return (-1);
 
-	if (match_keypair) {
-		if (strcmp(sc1->tls_cert_file, sc2->tls_cert_file) != 0)
-			return (-1);
-		if (strcmp(sc1->tls_key_file, sc2->tls_key_file) != 0)
-			return (-1);
-	}
-
 	return (0);
 }
 
@@ -257,10 +243,6 @@
 	if ((srv->srv_conf.flags & SRVFLAG_TLS) == 0)
 		return (0);
 
-	if (srv->srv_conf.tls_cert == NULL)
-		/* soft fail if cert is not there yet */
-		return (0);
-
 	log_debug("%s: setting up tls for %s", __func__, srv->srv_conf.name);
 
 	if (tls_init() != 0) {
@@ -1160,7 +1142,7 @@
 	if (srv->srv_conf.flags & SRVFLAG_TLS) {
 		if (tls_accept_socket(srv->srv_tls_ctx, &clt->clt_tls_ctx,
 		    clt->clt_s) != 0) {
-			server_close(clt, "failed to setup tls context");
+			server_close(clt, "failed to accept tls socket");
 			return;
 		}
 		event_again(&clt->clt_ev, clt->clt_s, EV_TIMEOUT|EV_READ,
@@ -1262,12 +1244,14 @@
 	iov[0].iov_base = &srv_conf->id;
 	iov[0].iov_len = sizeof(srv_conf->id);
 	iov[1].iov_base = msg;
-	iov[1].iov_len = strlen(msg) + 1;
+	iov[1].iov_len = ret + 1;
 
 	if (proc_composev(httpd_env->sc_ps, PROC_LOGGER, cmd, iov, 2) != 0) {
 		log_warn("%s: failed to compose imsg", __func__);
+		free(msg);
 		return;
 	}
+	free(msg);
 }
 
 void
@@ -1325,6 +1309,11 @@
 	/* free the HTTP descriptors incl. headers */
 	server_close_http(clt);
 
+	/* tls_close must be called before the underlying socket is closed. */
+	if (clt->clt_tls_ctx != NULL)
+		tls_close(clt->clt_tls_ctx); /* XXX - error handling */
+	tls_free(clt->clt_tls_ctx);
+
 	event_del(&clt->clt_ev);
 	if (clt->clt_bev != NULL)
 		bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);
@@ -1342,14 +1331,11 @@
 
 	if (clt->clt_srvbev != NULL)
 		bufferevent_free(clt->clt_srvbev);
+
 	if (clt->clt_fd != -1)
 		close(clt->clt_fd);
 	if (clt->clt_s != -1)
 		close(clt->clt_s);
-
-	if (clt->clt_tls_ctx != NULL)
-		tls_close(clt->clt_tls_ctx);
-	tls_free(clt->clt_tls_ctx);
 
 	server_inflight_dec(clt, __func__);
 
Index: usr.sbin/httpd/server_fcgi.c
@@ -97,45 +97,16 @@
 	size_t				 scriptlen;
 	int				 pathlen;
 	int				 fd = -1, ret;
-	const char			*stripped, *p, *alias, *errstr = NULL;
+	const char			*stripped, *alias, *errstr = NULL;
 	char				*query_alias, *str, *script = NULL;
 
-	if (srv_conf->socket[0] == ':') {
-		struct sockaddr_storage	 ss;
-		in_port_t		 port;
-
-		p = srv_conf->socket + 1;
-
-		port = strtonum(p, 0, 0xffff, &errstr);
-		if (errstr != NULL) {
-			log_warn("%s: strtonum %s, %s", __func__, p, errstr);
+	if ((fd = socket(srv_conf->fastcgi_ss.ss_family,
+	    SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1)
+		goto fail;
+	if ((connect(fd, (struct sockaddr *) &srv_conf->fastcgi_ss,
+	    srv_conf->fastcgi_ss.ss_len)) == -1) {
+		if (errno != EINPROGRESS)
 			goto fail;
-		}
-		memset(&ss, 0, sizeof(ss));
-		ss.ss_family = AF_INET;
-		((struct sockaddr_in *)
-		    &ss)->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-		port = htons(port);
-
-		if ((fd = server_socket_connect(&ss, port, srv_conf)) == -1)
-			goto fail;
-	} else {
-		struct sockaddr_un	 sun;
-
-		if ((fd = socket(AF_UNIX,
-		    SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1)
-			goto fail;
-
-		memset(&sun, 0, sizeof(sun));
-		sun.sun_family = AF_UNIX;
-		if (strlcpy(sun.sun_path, srv_conf->socket,
-		    sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
-			errstr = "socket path to long";
-			goto fail;
-		}
-
-		if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1)
-			goto fail;
 	}
 
 	memset(hbuf, 0, sizeof(hbuf));
@@ -328,13 +299,13 @@
 	}
 
 	if (!desc->http_query) {
-		if (fcgi_add_param(&param, "REQUEST_URI", desc->http_path,
+		if (fcgi_add_param(&param, "REQUEST_URI", desc->http_path_orig,
 		    clt) == -1) {
 			errstr = "failed to encode param";
 			goto fail;
 		}
 	} else {
-		if (asprintf(&str, "%s?%s", desc->http_path,
+		if (asprintf(&str, "%s?%s", desc->http_path_orig,
 		    desc->http_query) == -1) {
 			errstr = "failed to encode param";
 			goto fail;
@@ -684,7 +655,7 @@
 
 	/* Date header is mandatory and should be added as late as possible */
 	key.kv_key = "Date";
-	if ((kv = kv_find(&resp->http_headers, &key)) == NULL &&
+	if (kv_find(&resp->http_headers, &key) == NULL &&
 	    (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0 ||
 	    kv_add(&resp->http_headers, "Date", tmbuf) == NULL))
 		return (-1);
Index: usr.sbin/httpd/server_file.c
@@ -167,11 +167,18 @@
 	struct server_config	*srv_conf = clt->clt_srv_conf;
 	char			 path[PATH_MAX];
 	const char		*stripped, *errstr = NULL;
-	int			 ret = 500;
+	int			 ret = 500, rootfd;
 
 	if (srv_conf->flags & SRVFLAG_FCGI)
 		return (server_fcgi(env, clt));
 
+	/* If the server root is not accessible, we have a problem */
+	if ((rootfd = open_server_root(srv_conf, O_RDONLY)) == -1) {
+		errstr = srv_conf->root;
+		goto abort;
+	}
+	close(rootfd);
+
 	/* Request path is already canonicalized */
 	stripped = server_root_strip(
 	    desc->http_path_alias != NULL ?
@@ -224,6 +231,7 @@
 	struct media_type	*media;
 	const char		*errstr = NULL;
 	int			 fd = -1, ret, code = 500;
+	size_t			 bufsiz;
 
 	if ((ret = server_file_method(clt)) != 0) {
 		code = ret;
@@ -269,9 +277,10 @@
 		goto fail;
 	}
 
-	/* Adjust read watermark to the socket output buffer size */
+	/* Adjust read watermark to the optimal file io size */
+	bufsiz = MAXIMUM(st->st_blksize, 64 * 1024);
 	bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,
-	    clt->clt_sndbufsiz);
+	    bufsiz);
 
 	bufferevent_settimeout(clt->clt_srvbev,
 	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
@@ -304,7 +313,7 @@
 	struct media_type	*media, multipart_media;
 	struct range_data	*r = &clt->clt_ranges;
 	struct range		*range;
-	size_t			 content_length = 0;
+	size_t			 content_length = 0, bufsiz;
 	int			 code = 500, fd = -1, i, nranges, ret;
 	char			 content_range[64];
 	const char		*errstr = NULL;
@@ -403,9 +412,10 @@
 		goto fail;
 	}
 
-	/* Adjust read watermark to the socket output buffer size */
+	/* Adjust read watermark to the optimal file io size */
+	bufsiz = MAXIMUM(st->st_blksize, 64 * 1024);
 	bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,
-	    clt->clt_sndbufsiz);
+	    bufsiz);
 
 	bufferevent_settimeout(clt->clt_srvbev,
 	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
@@ -477,14 +487,17 @@
 
 	/* A CSS stylesheet allows minimal customization by the user */
 	style = "body { background-color: white; color: black; font-family: "
-	    "sans-serif; }\nhr { border: 0; border-bottom: 1px dashed; }\n";
+	    "sans-serif; }\nhr { border: 0; border-bottom: 1px dashed; }\n"
+	    "@media (prefers-color-scheme: dark) {\n"
+	    "body { background-color: #1E1F21; color: #EEEFF1; }\n"
+	    "a { color: #BAD7FF; }\n}";
+
 	/* Generate simple HTML index document */
 	if (evbuffer_add_printf(evb,
 	    "<!DOCTYPE html>\n"
 	    "<html>\n"
 	    "<head>\n"
-	    "<meta http-equiv=\"Content-Type\" content=\"text/html; "
-	    "charset=utf-8\"/>\n"
+	    "<meta charset=\"utf-8\">\n"
 	    "<title>Index of %s</title>\n"
 	    "<style type=\"text/css\"><!--\n%s\n--></style>\n"
 	    "</head>\n"
Index: usr.sbin/httpd/server_http.c
@@ -1,6 +1,7 @@
 /*	$OpenBSD: server_http.c,v 1.137 2020/02/25 15:18:41 sthen Exp $	*/
 
 /*
+ * Copyright (c) 2020 Matthias Pressfreund
  * Copyright (c) 2006 - 2018 Reyk Floeter <reyk@openbsd.org>
  *
  * Permission to use, copy, modify, and distribute this software for any
@@ -20,6 +21,7 @@
 #include <sys/queue.h>
 #include <sys/socket.h>
 #include <sys/tree.h>
+#include <sys/stat.h>
 
 #include <netinet/in.h>
 #include <arpa/inet.h>
@@ -36,6 +38,7 @@
 #include <event.h>
 #include <ctype.h>
 #include <vis.h>
+#include <fcntl.h>
 
 #include "httpd.h"
 #include "http.h"
@@ -48,6 +51,8 @@
 		    struct client *);
 char		*server_expand_http(struct client *, const char *,
 		    char *, size_t);
+int		 server_locationaccesstest(struct server_config *,
+		    const char *);
 
 static struct http_method	 http_methods[] = HTTP_METHODS;
 static struct http_error	 http_errors[] = HTTP_ERRORS;
@@ -100,6 +105,8 @@
 
 	free(desc->http_path);
 	desc->http_path = NULL;
+	free(desc->http_path_orig);
+	desc->http_path_orig = NULL;
 	free(desc->http_path_alias);
 	desc->http_path_alias = NULL;
 	free(desc->http_query);
@@ -921,15 +928,17 @@
 	/* A CSS stylesheet allows minimal customization by the user */
 	style = "body { background-color: white; color: black; font-family: "
 	    "'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif; }\n"
-	    "hr { border: 0; border-bottom: 1px dashed; }\n";
+	    "hr { border: 0; border-bottom: 1px dashed; }\n"
+	    "@media (prefers-color-scheme: dark) {\n"
+	    "body { background-color: #1E1F21; color: #EEEFF1; }\n"
+	    "a { color: #BAD7FF; }\n}";
 
 	/* Generate simple HTML error document */
 	if ((bodylen = asprintf(&body,
 	    "<!DOCTYPE html>\n"
 	    "<html>\n"
 	    "<head>\n"
-	    "<meta http-equiv=\"Content-Type\" content=\"text/html; "
-	    "charset=utf-8\"/>\n"
+	    "<meta charset=\"utf-8\">\n"
 	    "<title>%03d %s</title>\n"
 	    "<style type=\"text/css\"><!--\n%s\n--></style>\n"
 	    "</head>\n"
@@ -1202,11 +1211,15 @@
 	char			*hostval, *query;
 	const char		*errstr = NULL;
 
-	/* Decode the URL */
+	/* Preserve original path */
 	if (desc->http_path == NULL ||
-	    url_decode(desc->http_path) == NULL)
+	    (desc->http_path_orig = strdup(desc->http_path)) == NULL)
 		goto fail;
 
+	/* Decode the URL */
+	if (url_decode(desc->http_path) == NULL)
+		goto fail;
+
 	/* Canonicalize the request path */
 	if (canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)
 		goto fail;
@@ -1271,8 +1284,7 @@
 				    hostname, FNM_CASEFOLD);
 			}
 			if (ret == 0 &&
-			    (portval == -1 ||
-			    (portval != -1 && portval == srv_conf->port))) {
+			    (portval == -1 || portval == srv_conf->port)) {
 				/* Replace host configuration */
 				clt->clt_srv_conf = srv_conf;
 				srv_conf = NULL;
@@ -1310,7 +1322,8 @@
 		goto fail;
 
 	/* Now search for the location */
-	srv_conf = server_getlocation(clt, desc->http_path);
+	if ((srv_conf = server_getlocation(clt, desc->http_path)) == NULL)
+		goto rooterr;
 
 	/* Optional rewrite */
 	if (srv_conf->flags & SRVFLAG_PATH_REWRITE) {
@@ -1346,7 +1359,9 @@
 			goto fail;
 
 		/* Now search for the updated location */
-		srv_conf = server_getlocation(clt, desc->http_path_alias);
+		if ((srv_conf = server_getlocation(clt,
+		    desc->http_path_alias)) == NULL)
+			goto rooterr;
 	}
 
 	if (clt->clt_toread > 0 && (size_t)clt->clt_toread >
@@ -1368,6 +1383,11 @@
  fail:
 	server_abort_http(clt, 400, "bad request");
 	return (-1);
+
+ rooterr: /* server root inaccessible */
+	srv_conf = clt->clt_srv_conf;
+	server_abort_http(clt, 500, srv_conf->root);
+	return (-1);
 }
 
 const char *
@@ -1412,6 +1432,12 @@
 				    path, FNM_CASEFOLD);
 			}
 			if (ret == 0 && errstr == NULL) {
+				if ((ret = server_locationaccesstest(location,
+				    path)) == -1)
+					return (NULL);
+
+				if (ret)
+					continue;
 				/* Replace host configuration */
 				clt->clt_srv_conf = srv_conf = location;
 				break;
@@ -1420,6 +1446,28 @@
 	}
 
 	return (srv_conf);
+}
+
+int
+server_locationaccesstest(struct server_config *srv_conf, const char *path)
+{
+	int		 rootfd, ret;
+	struct stat	 sb;
+
+	if (((SRVFLAG_LOCATION_FOUND | SRVFLAG_LOCATION_NOT_FOUND) &
+	    srv_conf->flags) == 0)
+		return (0);
+
+	/* If the server root is not accessible, we have a problem */
+	if ((rootfd = open_server_root(srv_conf, O_RDONLY)) == -1)
+		return (-1);
+
+	path = server_root_strip(path, srv_conf->strip) + 1;
+	if ((ret = faccessat(rootfd, path, R_OK, 0)) != -1)
+		ret = fstatat(rootfd, path, &sb, 0);
+	close(rootfd);
+	return ((ret == -1 && SRVFLAG_LOCATION_FOUND & srv_conf->flags) ||
+	    (ret == 0 && SRVFLAG_LOCATION_NOT_FOUND & srv_conf->flags));
 }
 
 int
