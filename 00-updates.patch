
Copyright (c) 2020, 2021 Matthias Pressfreund

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Index: usr.sbin/httpd/config.c
@@ -489,7 +489,12 @@
 		/* Inherit configuration from the parent */
 		f = SRVFLAG_INDEX|SRVFLAG_NO_INDEX;
 		if ((srv_conf->flags & f) == 0) {
-			srv_conf->flags |= parent->flags & f;
+			/*
+			 * Inherit index flags from parent server only if
+			 * auto-index flag of location is not set
+			 */
+			if ((srv_conf->flags & SRVFLAG_AUTO_INDEX) == 0)
+				srv_conf->flags |= parent->flags & f;
 			(void)strlcpy(srv_conf->index, parent->index,
 			    sizeof(srv_conf->index));
 		}
Index: usr.sbin/httpd/control.c
@@ -34,7 +34,7 @@
 
 #define	CONTROL_BACKLOG	5
 
-struct ctl_connlist ctl_conns;
+struct ctl_connlist ctl_conns = TAILQ_HEAD_INITIALIZER(ctl_conns);
 
 void		 control_accept(int, short, void *);
 void		 control_close(int, struct control_sock *);
Index: usr.sbin/httpd/httpd.8
@@ -1,5 +1,6 @@
 .\"	$OpenBSD: httpd.8,v 1.53 2016/09/15 20:57:07 jmc Exp $
 .\"
+.\" Copyright (c) 2021 Matthias Pressfreund
 .\" Copyright (c) 2014 Reyk Floeter <reyk@openbsd.org>
 .\"
 .\" Permission to use, copy, modify, and distribute this software for any
@@ -41,6 +42,10 @@
 .Dv SIGHUP
 and reopens log files when it receives
 .Dv SIGUSR1 .
+.Pp
+It is furthermore equipped with the additional functionality provided by the
+.Lk https://github.com/mpfr/httpd-plus httpd-plus
+add-on package.
 .Pp
 The options are as follows:
 .Bl -tag -width Dssmacro=value
Index: usr.sbin/httpd/httpd.c
@@ -67,6 +67,8 @@
 	{ "logger",	PROC_LOGGER, parent_dispatch_logger, logger }
 };
 
+enum privsep_procid privsep_process;
+
 void
 parent_sig_handler(int sig, short event, void *arg)
 {
Index: usr.sbin/httpd/httpd.conf.5
@@ -1,5 +1,6 @@
 .\"	$OpenBSD: httpd.conf.5,v 1.113 2020/09/05 11:49:38 tb Exp $
 .\"
+.\" Copyright (c) 2020, 2021 Matthias Pressfreund
 .\" Copyright (c) 2014, 2015 Reyk Floeter <reyk@openbsd.org>
 .\"
 .\" Permission to use, copy, modify, and distribute this software for any
@@ -14,7 +15,7 @@
 .\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 .\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 .\"
-.Dd $Mdocdate: September 5 2020 $
+.Dd $Mdocdate: June 7 2021 $
 .Dt HTTPD.CONF 5
 .Os
 .Sh NAME
@@ -23,7 +24,10 @@
 .Sh DESCRIPTION
 .Nm
 is the configuration file for the HTTP daemon,
-.Xr httpd 8 .
+.Xr httpd 8 ,
+which is equipped with the additional functionality provided by the
+.Lk https://github.com/mpfr/httpd-plus httpd-plus
+add-on package.
 .Pp
 .Nm
 is divided into the following main sections:
@@ -155,7 +159,7 @@
 .Xr patterns 7 .
 .El
 .Pp
-Followed by a block of options that is enclosed in curly brackets:
+Followed by a block of options enclosed in curly braces:
 .Bl -tag -width Ds
 .It Ic alias Ar name
 Specify an additional alias
@@ -194,9 +198,8 @@
 response.
 The optional
 .Ar uri
-argument can be used with return codes in the 3xx range to send a
-.Sq Location:
-header for redirection to a specified URI.
+argument can be used with return codes in the 3xx range to send an
+HTTP Location header for redirection to a specified URI.
 .Pp
 It is possible to rewrite the request to redirect it to a different
 external location.
@@ -282,6 +285,7 @@
 .El
 .It Oo Ic no Oc Ic fastcgi Oo Ar option Oc
 Enable FastCGI instead of serving files.
+Multiple options may be specified within curly braces.
 Valid options are:
 .Bl -tag -width Ds
 .It Ic socket Oo Cm tcp Oc Ar socket Oo Ar port Oc
@@ -399,11 +403,16 @@
 .It Ic listen on Ar address Oo Ic tls Oc Ic port Ar number
 Set the listen address and port.
 This statement can be specified multiple times.
-.It Ic location Ar path Brq ...
+.It Ic location Oo Oo Ic not Oc Ic found Oc Ar path Brq ...
 Specify server configuration rules for a specific location.
 The
 .Ar path
 argument will be matched against the request path with shell globbing rules.
+Optionally, it is also possible to match for
+.Ic found
+(i.e. accessible) or
+.Ic not found
+request paths only.
 In case of multiple location statements in the same context, the
 first matching location statement will be put into effect, while all
 later ones will be ignored.
@@ -419,7 +428,7 @@
 .Ic tcp
 and
 .Ic tls .
-.It Ic location match Ar path Brq ...
+.It Ic location Oo Oo Ic not Oc Ic found Oc Ic match Ar path Brq ...
 Like the
 .Ic location
 option,
@@ -792,6 +801,7 @@
 	listen on 10.0.0.1 tls port 443
 }
 .Ed
+.Pp
 The request can also be rewritten with the
 .Ic request rewrite
 directive:
@@ -802,6 +812,41 @@
 		request rewrite "/new/%1"
 	}
 }
+.Ed
+The
+.Ic location not found
+option may be used to enable
+.Lk https://wordpress.org/support/article/using-permalinks/ WordPress Pretty Permalinks
+just like on an Apache web server with
+.Pa mod_rewrite
+installed.
+.Bd -literal -offset indent
+server "www.example.com" {
+	listen on * port www
+	directory index "index.php"
+
+	location not found "/*" {
+		request rewrite "/index.php"
+	}
+	location "/*.php" {
+		fastcgi socket "/run/php-fpm.sock"
+	}
+}
+.Ed
+WordPress, however, is unable to discover that
+.Xr httpd 8
+is now capable to perform required URL rewrites.
+This will make the
+.Lk https://wordpress.org/support/article/settings-permalinks-screen/ Permalink Settings Screen
+not behave as expected.
+Luckily, and for this case exactly, the
+.Lk https://developer.wordpress.org/reference/hooks/got_url_rewrite/ got_url_rewrite hook
+exists.
+Adding the following line of code into the current theme's
+.Pa functions.php
+file will straighten things out.
+.Bd -literal -offset indent
+add_filter('got_url_rewrite', '__return_true');
 .Ed
 .Sh SEE ALSO
 .Xr htpasswd 1 ,
Index: usr.sbin/httpd/httpd.h
@@ -1,6 +1,7 @@
 /*	$OpenBSD: httpd.h,v 1.152 2020/08/29 07:53:48 florian Exp $	*/
 
 /*
+ * Copyright (c) 2020 Matthias Pressfreund
  * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>
  * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@openbsd.org>
  * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
@@ -168,7 +169,7 @@
 };
 TAILQ_HEAD(control_socks, control_sock);
 
-struct {
+extern struct {
 	struct event	 ev;
 	int		 fd;
 } control_state;
@@ -230,7 +231,8 @@
 	PROC_SERVER,
 	PROC_LOGGER,
 	PROC_MAX
-} privsep_process;
+};
+extern enum privsep_procid privsep_process;
 
 /* Attach the control socket to the following process */
 #define PROC_CONTROL	PROC_LOGGER
@@ -299,6 +301,7 @@
 	int			 end;
 	int			 status;
 	int			 headersdone;
+	int			 headerssent;
 };
 
 struct range {
@@ -391,13 +394,16 @@
 #define SRVFLAG_DEFAULT_TYPE	0x00800000
 #define SRVFLAG_PATH_REWRITE	0x01000000
 #define SRVFLAG_NO_PATH_REWRITE	0x02000000
+#define SRVFLAG_LOCATION_FOUND	0x40000000
+#define SRVFLAG_LOCATION_NOT_FOUND 0x80000000
 
 #define SRVFLAG_BITS							\
 	"\10\01INDEX\02NO_INDEX\03AUTO_INDEX\04NO_AUTO_INDEX"		\
 	"\05ROOT\06LOCATION\07FCGI\10NO_FCGI\11LOG\12NO_LOG"		\
 	"\14SYSLOG\15NO_SYSLOG\16TLS\17ACCESS_LOG\20ERROR_LOG"		\
 	"\21AUTH\22NO_AUTH\23BLOCK\24NO_BLOCK\25LOCATION_MATCH"		\
-	"\26SERVER_MATCH\27SERVER_HSTS\30DEFAULT_TYPE\31PATH\32NO_PATH"
+	"\26SERVER_MATCH\27SERVER_HSTS\30DEFAULT_TYPE\31PATH\32NO_PATH" \
+	"\37LOCATION_FOUND\40LOCATION_NOT_FOUND"
 
 #define TCPFLAG_NODELAY		0x01
 #define TCPFLAG_NNODELAY	0x02
@@ -435,7 +441,7 @@
 	uint32_t		log_id;
 	TAILQ_ENTRY(log_file)	log_entry;
 };
-TAILQ_HEAD(log_files, log_file) log_files;
+extern TAILQ_HEAD(log_files, log_file) log_files;
 
 struct media_type {
 	char			 media_name[MEDIATYPE_NAMEMAX];
@@ -609,8 +615,6 @@
 struct ctl_conn	*
 	 control_connbyfd(int);
 
-extern  struct ctl_connlist ctl_conns;
-
 /* parse.y */
 int	 parse_config(const char *, struct httpd *);
 int	 load_config(const char *, struct httpd *);
@@ -618,7 +622,7 @@
 
 /* server.c */
 void	 server(struct privsep *, struct privsep_proc *);
-int	 server_tls_cmp(struct server *, struct server *, int);
+int	 server_tls_cmp(struct server *, struct server *);
 int	 server_tls_load_ca(struct server *);
 int	 server_tls_load_crl(struct server *);
 int	 server_tls_load_keypair(struct server *);
@@ -661,6 +665,9 @@
 	 server_match(struct server *, int);
 
 SPLAY_PROTOTYPE(client_tree, client, clt_nodes, server_client_cmp);
+
+#define open_server_root(srv_conf, mode)				\
+	open(*(srv_conf)->root != '\0' ? (srv_conf)->root : "/", mode)
 
 /* server_http.c */
 void	 server_http_init(struct server *);
Index: usr.sbin/httpd/logger.c
@@ -45,6 +45,8 @@
 
 static uint32_t		 last_log_id = 0;
 
+struct log_files log_files;
+
 static struct privsep_proc procs[] = {
 	{ "parent",	PROC_PARENT,	logger_dispatch_parent },
 	{ "server",	PROC_SERVER,	logger_dispatch_server }
@@ -89,6 +91,7 @@
 			log->log_fd = -1;
 		}
 		TAILQ_REMOVE(&log_files, log, log_entry);
+		free(log);
 	}
 }
 
Index: usr.sbin/httpd/parse.y
@@ -1,6 +1,7 @@
 /*	$OpenBSD: parse.y,v 1.117 2020/08/26 06:50:20 florian Exp $	*/
 
 /*
+ * Copyright (c) 2020 Matthias Pressfreund
  * Copyright (c) 2007 - 2015 Reyk Floeter <reyk@openbsd.org>
  * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org>
  * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@openbsd.org>
@@ -118,6 +119,7 @@
 int		 getservice(char *);
 int		 is_if_in_group(const char *, const char *);
 int		 get_fastcgi_dest(struct server_config *, const char *, char *);
+void		 remove_locations(struct server_config *);
 
 typedef struct {
 	union {
@@ -126,10 +128,6 @@
 		struct timeval		 tv;
 		struct portrange	 port;
 		struct auth		 auth;
-		struct {
-			struct sockaddr_storage	 ss;
-			char			 name[HOST_NAME_MAX+1];
-		}			 addr;
 	} v;
 	int lineno;
 } YYSTYPE;
@@ -142,12 +140,12 @@
 %token	PROTOCOLS REQUESTS ROOT SACK SERVER SOCKET STRIP STYLE SYSLOG TCP TICKET
 %token	TIMEOUT TLS TYPE TYPES HSTS MAXAGE SUBDOMAINS DEFAULT PRELOAD REQUEST
 %token	ERROR INCLUDE AUTHENTICATE WITH BLOCK DROP RETURN PASS REWRITE
-%token	CA CLIENT CRL OPTIONAL PARAM FORWARDED
+%token	CA CLIENT CRL OPTIONAL PARAM FORWARDED FOUND NOT
 %token	<v.string>	STRING
 %token  <v.number>	NUMBER
 %type	<v.port>	port
 %type	<v.string>	fcgiport
-%type	<v.number>	opttls optmatch
+%type	<v.number>	opttls optmatch optfound
 %type	<v.tv>		timeout
 %type	<v.string>	numberstring optstring
 %type	<v.auth>	authopts
@@ -335,7 +333,8 @@
 					free(srv);
 					YYERROR;
 				}
-				if (server_tls_cmp(s, srv, 0) != 0) {
+				if (srv->srv_conf.flags & SRVFLAG_TLS &&
+				    server_tls_cmp(s, srv) != 0) {
 					yyerror("server \"%s\": tls "
 					    "configuration mismatch on same "
 					    "address/port",
@@ -355,11 +354,20 @@
 				YYERROR;
 			}
 
-			if (server_tls_load_keypair(srv) == -1)
+			if (server_tls_load_keypair(srv) == -1) {
+				/* Soft fail as there may be no certificate. */
 				log_warnx("%s:%d: server \"%s\": failed to "
 				    "load public/private keys", file->name,
 				    yylval.lineno, srv->srv_conf.name);
 
+				remove_locations(srv_conf);
+				serverconfig_free(srv_conf);
+				srv_conf = NULL;
+				free(srv);
+				srv = NULL;
+				break;
+			}
+
 			if (server_tls_load_ca(srv) == -1) {
 				yyerror("server \"%s\": failed to load "
 				    "ca cert(s)", srv->srv_conf.name);
@@ -506,39 +514,39 @@
 		| fastcgi
 		| authenticate
 		| filter
-		| LOCATION optmatch STRING	{
+		| LOCATION optfound optmatch STRING	{
 			struct server		*s;
 			struct sockaddr_un	*sun;
 
 			if (srv->srv_conf.ss.ss_family == AF_UNSPEC) {
 				yyerror("listen address not specified");
-				free($3);
+				free($4);
 				YYERROR;
 			}
 
 			if (parentsrv != NULL) {
-				yyerror("location %s inside location", $3);
-				free($3);
+				yyerror("location %s inside location", $4);
+				free($4);
 				YYERROR;
 			}
 
 			if (!loadcfg) {
-				free($3);
+				free($4);
 				YYACCEPT;
 			}
 
 			if ((s = calloc(1, sizeof (*s))) == NULL)
 				fatal("out of memory");
 
-			if (strlcpy(s->srv_conf.location, $3,
+			if (strlcpy(s->srv_conf.location, $4,
 			    sizeof(s->srv_conf.location)) >=
 			    sizeof(s->srv_conf.location)) {
 				yyerror("server location truncated");
-				free($3);
+				free($4);
 				free(s);
 				YYERROR;
 			}
-			free($3);
+			free($4);
 
 			if (strlcpy(s->srv_conf.name, srv->srv_conf.name,
 			    sizeof(s->srv_conf.name)) >=
@@ -558,7 +566,18 @@
 			/* A location entry uses the parent id */
 			s->srv_conf.parent_id = srv->srv_conf.id;
 			s->srv_conf.flags = SRVFLAG_LOCATION;
-			if ($2)
+			if ($2 == 1) {
+				s->srv_conf.flags &=
+				    ~SRVFLAG_LOCATION_NOT_FOUND;
+				s->srv_conf.flags |=
+				    SRVFLAG_LOCATION_FOUND;
+			} else if ($2 == -1) {
+				s->srv_conf.flags &=
+				    ~SRVFLAG_LOCATION_FOUND;
+				s->srv_conf.flags |=
+				    SRVFLAG_LOCATION_NOT_FOUND;
+			}
+			if ($3)
 				s->srv_conf.flags |= SRVFLAG_LOCATION_MATCH;
 			s->srv_s = -1;
 			memcpy(&s->srv_conf.ss, &srv->srv_conf.ss,
@@ -578,10 +597,18 @@
 			SPLAY_INIT(&srv->srv_clients);
 		} '{' optnl serveropts_l '}'	{
 			struct server	*s = NULL;
+			uint32_t	 f;
 
+			f = SRVFLAG_LOCATION_FOUND |
+			    SRVFLAG_LOCATION_NOT_FOUND;
+
 			TAILQ_FOREACH(s, conf->sc_servers, srv_entry) {
+				/* Compare locations of same parent server */
 				if ((s->srv_conf.flags & SRVFLAG_LOCATION) &&
-				    s->srv_conf.id == srv_conf->id &&
+				    s->srv_conf.parent_id ==
+				    srv_conf->parent_id &&
+				    (s->srv_conf.flags & f) ==
+				    (srv_conf->flags & f) &&
 				    strcmp(s->srv_conf.location,
 				    srv_conf->location) == 0)
 					break;
@@ -619,6 +646,11 @@
 		}
 		;
 
+optfound	: /* empty */	{ $$ = 0; }
+		| FOUND		{ $$ = 1; }
+		| NOT FOUND	{ $$ = -1; }
+		;
+
 hsts		: HSTS '{' optnl hstsflags_l '}'
 		| HSTS hstsflags
 		| HSTS
@@ -1367,6 +1399,7 @@
 		{ "error",		ERR },
 		{ "fastcgi",		FCGI },
 		{ "forwarded",		FORWARDED },
+		{ "found",		FOUND },
 		{ "hsts",		HSTS },
 		{ "include",		INCLUDE },
 		{ "index",		INDEX },
@@ -1382,6 +1415,7 @@
 		{ "max-age",		MAXAGE },
 		{ "no",			NO },
 		{ "nodelay",		NODELAY },
+		{ "not",		NOT },
 		{ "ocsp",		OCSP },
 		{ "on",			ON },
 		{ "optional",		OPTIONAL },
@@ -2094,7 +2128,8 @@
 
  nextaf:
 	for (p = ifap; p != NULL && cnt < max; p = p->ifa_next) {
-		if (p->ifa_addr->sa_family != af ||
+		if (p->ifa_addr == NULL ||
+		    p->ifa_addr->sa_family != af ||
 		    (strcmp(s, p->ifa_name) != 0 &&
 		    !is_if_in_group(p->ifa_name, s)))
 			continue;
@@ -2109,6 +2144,7 @@
 				log_warnx("%s: interface name truncated",
 				    __func__);
 			freeifaddrs(ifap);
+			free(h);
 			return (-1);
 		}
 		if (ipproto != -1)
@@ -2458,4 +2494,19 @@
 	freeaddrinfo(res);
 
 	return (0);
+}
+
+void
+remove_locations(struct server_config *xsrv_conf)
+{
+	struct server *s, *next;
+
+	TAILQ_FOREACH_SAFE(s, conf->sc_servers, srv_entry, next) {
+		if (!(s->srv_conf.flags & SRVFLAG_LOCATION &&
+		    s->srv_conf.parent_id == xsrv_conf->parent_id))
+			continue;
+		TAILQ_REMOVE(conf->sc_servers, s, srv_entry);
+		serverconfig_free(&s->srv_conf);
+		free(s);
+	}
 }
Index: usr.sbin/httpd/proc.c
@@ -588,7 +588,6 @@
 	proc_setup(ps, procs, nproc);
 	proc_accept(ps, PROC_PARENT_SOCK_FILENO, PROC_PARENT, 0);
 	if (p->p_id == PROC_CONTROL && ps->ps_instance == 0) {
-		TAILQ_INIT(&ctl_conns);
 		if (control_listen(&ps->ps_csock) == -1)
 			fatalx("%s: control_listen", __func__);
 		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
Index: usr.sbin/httpd/server.c
@@ -119,13 +119,6 @@
 	}
 
 	/* Open listening socket in the privileged process */
-	if ((srv->srv_conf.flags & SRVFLAG_TLS) && srv->srv_conf.tls_cert ==
-	    NULL) {
-		/* soft fail if cert is not there yet */
-		srv->srv_s = -1;
-		return (0);
-	}
-
 	if ((srv->srv_s = server_socket_listen(&srv->srv_conf.ss,
 	    srv->srv_conf.port, &srv->srv_conf)) == -1)
 		return (-1);
@@ -134,7 +127,7 @@
 }
 
 int
-server_tls_cmp(struct server *s1, struct server *s2, int match_keypair)
+server_tls_cmp(struct server *s1, struct server *s2)
 {
 	struct server_config	*sc1, *sc2;
 
@@ -154,13 +147,6 @@
 	if (strcmp(sc1->tls_ecdhe_curves, sc2->tls_ecdhe_curves) != 0)
 		return (-1);
 
-	if (match_keypair) {
-		if (strcmp(sc1->tls_cert_file, sc2->tls_cert_file) != 0)
-			return (-1);
-		if (strcmp(sc1->tls_key_file, sc2->tls_key_file) != 0)
-			return (-1);
-	}
-
 	return (0);
 }
 
@@ -257,10 +243,6 @@
 	if ((srv->srv_conf.flags & SRVFLAG_TLS) == 0)
 		return (0);
 
-	if (srv->srv_conf.tls_cert == NULL)
-		/* soft fail if cert is not there yet */
-		return (0);
-
 	log_debug("%s: setting up tls for %s", __func__, srv->srv_conf.name);
 
 	if (tls_init() != 0) {
@@ -1160,7 +1142,7 @@
 	if (srv->srv_conf.flags & SRVFLAG_TLS) {
 		if (tls_accept_socket(srv->srv_tls_ctx, &clt->clt_tls_ctx,
 		    clt->clt_s) != 0) {
-			server_close(clt, "failed to setup tls context");
+			server_close(clt, "failed to accept tls socket");
 			return;
 		}
 		event_again(&clt->clt_ev, clt->clt_s, EV_TIMEOUT|EV_READ,
@@ -1262,12 +1244,14 @@
 	iov[0].iov_base = &srv_conf->id;
 	iov[0].iov_len = sizeof(srv_conf->id);
 	iov[1].iov_base = msg;
-	iov[1].iov_len = strlen(msg) + 1;
+	iov[1].iov_len = ret + 1;
 
 	if (proc_composev(httpd_env->sc_ps, PROC_LOGGER, cmd, iov, 2) != 0) {
 		log_warn("%s: failed to compose imsg", __func__);
+		free(msg);
 		return;
 	}
+	free(msg);
 }
 
 void
@@ -1325,6 +1309,11 @@
 	/* free the HTTP descriptors incl. headers */
 	server_close_http(clt);
 
+	/* tls_close must be called before the underlying socket is closed. */
+	if (clt->clt_tls_ctx != NULL)
+		tls_close(clt->clt_tls_ctx); /* XXX - error handling */
+	tls_free(clt->clt_tls_ctx);
+
 	event_del(&clt->clt_ev);
 	if (clt->clt_bev != NULL)
 		bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);
@@ -1342,14 +1331,11 @@
 
 	if (clt->clt_srvbev != NULL)
 		bufferevent_free(clt->clt_srvbev);
+
 	if (clt->clt_fd != -1)
 		close(clt->clt_fd);
 	if (clt->clt_s != -1)
 		close(clt->clt_s);
-
-	if (clt->clt_tls_ctx != NULL)
-		tls_close(clt->clt_tls_ctx);
-	tls_free(clt->clt_tls_ctx);
 
 	server_inflight_dec(clt, __func__);
 
Index: usr.sbin/httpd/server_fcgi.c
@@ -114,6 +114,7 @@
 	clt->clt_fcgi.toread = sizeof(struct fcgi_record_header);
 	clt->clt_fcgi.status = 200;
 	clt->clt_fcgi.headersdone = 0;
+	clt->clt_fcgi.headerssent = 0;
 
 	if (clt->clt_srvevb != NULL)
 		evbuffer_free(clt->clt_srvevb);
@@ -544,22 +545,20 @@
 				if (!clt->clt_fcgi.headersdone) {
 					clt->clt_fcgi.headersdone =
 					    server_fcgi_getheaders(clt);
-					if (clt->clt_fcgi.headersdone) {
-						if (server_fcgi_header(clt,
-						    clt->clt_fcgi.status)
-						    == -1) {
-							server_abort_http(clt,
-							    500,
-							    "malformed fcgi "
-							    "headers");
-							return;
-						}
-					}
 					if (!EVBUFFER_LENGTH(clt->clt_srvevb))
 						break;
 				}
 				/* FALLTHROUGH */
 			case FCGI_END_REQUEST:
+				if (clt->clt_fcgi.headersdone &&
+				    !clt->clt_fcgi.headerssent) {
+					if (server_fcgi_header(clt,
+					    clt->clt_fcgi.status) == -1) {
+						server_abort_http(clt, 500,
+						    "malformed fcgi headers");
+						return;
+					}
+				}
 				if (server_fcgi_writechunk(clt) == -1) {
 					server_abort_http(clt, 500,
 					    "encoding error");
@@ -600,6 +599,8 @@
 	char			 tmbuf[32];
 	struct kv		*kv, *cl, key;
 
+	clt->clt_fcgi.headerssent = 1;
+
 	if (desc == NULL || (error = server_httperror_byid(code)) == NULL)
 		return (-1);
 
@@ -615,6 +616,20 @@
 	if (kv_add(&resp->http_headers, "Server", HTTPD_SERVERNAME) == NULL)
 		return (-1);
 
+	if (clt->clt_fcgi.type == FCGI_END_REQUEST ||
+	    EVBUFFER_LENGTH(clt->clt_srvevb) == 0) {
+		/* Can't chunk encode an empty body. */
+		clt->clt_fcgi.chunked = 0;
+
+		/* But then we need a Content-Length... */
+		key.kv_key = "Content-Length";
+		if ((kv = kv_find(&resp->http_headers, &key)) == NULL) {
+			if (kv_add(&resp->http_headers,
+			    "Content-Length", "0") == NULL)
+				return (-1);
+		}
+	}
+
 	/* Set chunked encoding */
 	if (clt->clt_fcgi.chunked) {
 		/* XXX Should we keep and handle Content-Length instead? */
@@ -660,7 +675,6 @@
 	    kv_add(&resp->http_headers, "Date", tmbuf) == NULL))
 		return (-1);
 
-	/* Write initial header (fcgi might append more) */
 	if (server_writeresponse_http(clt) == -1 ||
 	    server_bufferevent_print(clt, "\r\n") == -1 ||
 	    server_headers(clt, resp, server_writeheader_http, NULL) == -1 ||
Index: usr.sbin/httpd/server_file.c
@@ -85,9 +85,7 @@
 		if (path[strlen(path) - 1] != '/') {
 			if ((encodedpath = url_encode(desc->http_path)) == NULL)
 				return (500);
-			if (asprintf(&newpath, "http%s://%s%s/",
-			    srv_conf->flags & SRVFLAG_TLS ? "s" : "",
-			    desc->http_host, encodedpath) == -1) {
+			if (asprintf(&newpath, "%s/", encodedpath) == -1) {
 				free(encodedpath);
 				return (500);
 			}
@@ -167,11 +165,18 @@
 	struct server_config	*srv_conf = clt->clt_srv_conf;
 	char			 path[PATH_MAX];
 	const char		*stripped, *errstr = NULL;
-	int			 ret = 500;
+	int			 ret = 500, rootfd;
 
 	if (srv_conf->flags & SRVFLAG_FCGI)
 		return (server_fcgi(env, clt));
 
+	/* If the server root is not accessible, we have a problem */
+	if ((rootfd = open_server_root(srv_conf, O_RDONLY)) == -1) {
+		errstr = srv_conf->root;
+		goto abort;
+	}
+	close(rootfd);
+
 	/* Request path is already canonicalized */
 	stripped = server_root_strip(
 	    desc->http_path_alias != NULL ?
@@ -224,6 +229,7 @@
 	struct media_type	*media;
 	const char		*errstr = NULL;
 	int			 fd = -1, ret, code = 500;
+	size_t			 bufsiz;
 
 	if ((ret = server_file_method(clt)) != 0) {
 		code = ret;
@@ -269,9 +275,10 @@
 		goto fail;
 	}
 
-	/* Adjust read watermark to the socket output buffer size */
+	/* Adjust read watermark to the optimal file io size */
+	bufsiz = MAXIMUM(st->st_blksize, 64 * 1024);
 	bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,
-	    clt->clt_sndbufsiz);
+	    bufsiz);
 
 	bufferevent_settimeout(clt->clt_srvbev,
 	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
@@ -304,7 +311,7 @@
 	struct media_type	*media, multipart_media;
 	struct range_data	*r = &clt->clt_ranges;
 	struct range		*range;
-	size_t			 content_length = 0;
+	size_t			 content_length = 0, bufsiz;
 	int			 code = 500, fd = -1, i, nranges, ret;
 	char			 content_range[64];
 	const char		*errstr = NULL;
@@ -403,9 +410,10 @@
 		goto fail;
 	}
 
-	/* Adjust read watermark to the socket output buffer size */
+	/* Adjust read watermark to the optimal file io size */
+	bufsiz = MAXIMUM(st->st_blksize, 64 * 1024);
 	bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,
-	    clt->clt_sndbufsiz);
+	    bufsiz);
 
 	bufferevent_settimeout(clt->clt_srvbev,
 	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
Index: usr.sbin/httpd/server_http.c
@@ -1,6 +1,7 @@
 /*	$OpenBSD: server_http.c,v 1.141 2020/09/12 07:34:17 yasuoka Exp $	*/
 
 /*
+ * Copyright (c) 2020 Matthias Pressfreund
  * Copyright (c) 2006 - 2018 Reyk Floeter <reyk@openbsd.org>
  *
  * Permission to use, copy, modify, and distribute this software for any
@@ -20,6 +21,7 @@
 #include <sys/queue.h>
 #include <sys/socket.h>
 #include <sys/tree.h>
+#include <sys/stat.h>
 
 #include <netinet/in.h>
 #include <arpa/inet.h>
@@ -36,6 +38,7 @@
 #include <event.h>
 #include <ctype.h>
 #include <vis.h>
+#include <fcntl.h>
 
 #include "httpd.h"
 #include "http.h"
@@ -48,6 +51,8 @@
 		    struct client *);
 char		*server_expand_http(struct client *, const char *,
 		    char *, size_t);
+int		 server_locationaccesstest(struct server_config *,
+		    const char *);
 
 static struct http_method	 http_methods[] = HTTP_METHODS;
 static struct http_error	 http_errors[] = HTTP_ERRORS;
@@ -1317,7 +1322,8 @@
 		goto fail;
 
 	/* Now search for the location */
-	srv_conf = server_getlocation(clt, desc->http_path);
+	if ((srv_conf = server_getlocation(clt, desc->http_path)) == NULL)
+		goto rooterr;
 
 	/* Optional rewrite */
 	if (srv_conf->flags & SRVFLAG_PATH_REWRITE) {
@@ -1353,7 +1359,9 @@
 			goto fail;
 
 		/* Now search for the updated location */
-		srv_conf = server_getlocation(clt, desc->http_path_alias);
+		if ((srv_conf = server_getlocation(clt,
+		    desc->http_path_alias)) == NULL)
+			goto rooterr;
 	}
 
 	if (clt->clt_toread > 0 && (size_t)clt->clt_toread >
@@ -1375,6 +1383,11 @@
  fail:
 	server_abort_http(clt, 400, "bad request");
 	return (-1);
+
+ rooterr: /* server root inaccessible */
+	srv_conf = clt->clt_srv_conf;
+	server_abort_http(clt, 500, srv_conf->root);
+	return (-1);
 }
 
 const char *
@@ -1419,6 +1432,12 @@
 				    path, FNM_CASEFOLD);
 			}
 			if (ret == 0 && errstr == NULL) {
+				if ((ret = server_locationaccesstest(location,
+				    path)) == -1)
+					return (NULL);
+
+				if (ret)
+					continue;
 				/* Replace host configuration */
 				clt->clt_srv_conf = srv_conf = location;
 				break;
@@ -1427,6 +1446,28 @@
 	}
 
 	return (srv_conf);
+}
+
+int
+server_locationaccesstest(struct server_config *srv_conf, const char *path)
+{
+	int		 rootfd, ret;
+	struct stat	 sb;
+
+	if (((SRVFLAG_LOCATION_FOUND | SRVFLAG_LOCATION_NOT_FOUND) &
+	    srv_conf->flags) == 0)
+		return (0);
+
+	/* If the server root is not accessible, we have a problem */
+	if ((rootfd = open_server_root(srv_conf, O_RDONLY)) == -1)
+		return (-1);
+
+	path = server_root_strip(path, srv_conf->strip) + 1;
+	if ((ret = faccessat(rootfd, path, R_OK, 0)) != -1)
+		ret = fstatat(rootfd, path, &sb, 0);
+	close(rootfd);
+	return ((ret == -1 && SRVFLAG_LOCATION_FOUND & srv_conf->flags) ||
+	    (ret == 0 && SRVFLAG_LOCATION_NOT_FOUND & srv_conf->flags));
 }
 
 int
